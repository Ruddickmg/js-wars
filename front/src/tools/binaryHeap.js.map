{"version":3,"file":"binaryHeap.js","sourceRoot":"","sources":["binaryHeap.ts"],"names":[],"mappings":"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","sourcesContent":["export interface BinaryHeap<HeapElement> {\n\n    size(): number;\n    top(): HeapElement;\n    pop(): HeapElement;\n    forEach(callback: (element: HeapElement) => any): void;\n    map(callback: (element: HeapElement) => HeapElement): BinaryHeap<HeapElement>;\n    push(value: HeapElement): BinaryHeap<HeapElement>;\n    setToMax(): BinaryHeap<HeapElement>;\n    setToMin(): BinaryHeap<HeapElement>;\n}\n\nexport default function binaryHeap<HeapElement>(\n\n    getValue = (value: HeapElement): HeapElement => value,\n\n): BinaryHeap<HeapElement> {\n\n    let heap: HeapElement[] = [];\n    let isMaxHeap: boolean = false;\n\n    const valueAtIndex = (currentHeap: HeapElement[], index: number): HeapElement => getValue(currentHeap[index - 1]);\n    const parent = (index: number): number => Math.floor(index / 2);\n    const leftChild = (index: number): number => index * 2;\n    const rightChild = (index: number): number => leftChild(index) + 1;\n    const swapChildWithParent = (\n\n        currentHeap: HeapElement[],\n        child: number = 2,\n        indexOfParent: number = 1,\n\n    ): HeapElement[] => {\n\n        const childIndex: number = child - 1;\n        const parentIndex: number = indexOfParent - 1;\n        const modifiedHeap: HeapElement[] = currentHeap.slice();\n\n        modifiedHeap[childIndex] = currentHeap[parentIndex];\n        modifiedHeap[parentIndex] = currentHeap[childIndex];\n\n        return modifiedHeap;\n    };\n    const rightIsNextBestHeapElement = (\n\n        currentHeap: HeapElement[],\n        leftChildIndex: number,\n        rightChildIndex: number,\n\n    ): boolean => {\n\n        const valueOfLeftChild: HeapElement = valueAtIndex(currentHeap, leftChildIndex);\n        const valueOfRightChild: HeapElement = valueAtIndex(currentHeap, rightChildIndex);\n\n        return isMaxHeap ?\n            valueOfLeftChild > valueOfRightChild :\n            valueOfLeftChild < valueOfRightChild;\n    };\n    const moveElementToPositionInHeap = (value: HeapElement, currentHeap: HeapElement[]): HeapElement[] => {\n\n        const index = currentHeap.length;\n        const boundary: number = 1;\n        const inBounds = (currentIndex: number): boolean => currentIndex > boundary;\n\n        let modifiedHeap: HeapElement[] = currentHeap.concat([value]);\n        let childIndex: number = index;\n        let parentIndex: number = parent(childIndex);\n\n        while (inBounds(childIndex) && rightIsNextBestHeapElement(modifiedHeap, childIndex, parentIndex)) {\n\n            modifiedHeap = swapChildWithParent(modifiedHeap, childIndex, parentIndex);\n            childIndex = parentIndex;\n            parentIndex = parent(childIndex);\n        }\n\n        return modifiedHeap;\n    };\n    const choseIndex = (currentHeap: HeapElement[], rightChildIndex: number, leftChildIndex: number): number => {\n\n        const isInBounds = currentHeap.length > rightChildIndex;\n\n        if (isInBounds && rightIsNextBestHeapElement(currentHeap, leftChildIndex, rightChildIndex)) {\n\n            return rightChildIndex;\n        }\n        return leftChildIndex;\n    };\n    const sortHeap = (currentHeap: HeapElement[], index: number): HeapElement[] => {\n\n        let parentIndex = index;\n        let childIndex = parentIndex;\n        let modifiedHeap = currentHeap.slice();\n        let leftChildIndex = leftChild(parentIndex);\n\n        const bounds = currentHeap.length;\n        const indexOfLastElement = bounds - 1;\n\n        while (leftChildIndex < bounds) {\n\n            childIndex = choseIndex(modifiedHeap, leftChildIndex, rightChild(parentIndex));\n            modifiedHeap = swapChildWithParent(modifiedHeap, childIndex, parentIndex);\n            parentIndex = childIndex;\n            leftChildIndex = leftChild(parentIndex);\n        }\n\n        if (childIndex <= bounds) {\n\n            return modifiedHeap;\n        }\n\n        modifiedHeap = swapChildWithParent(modifiedHeap, childIndex, indexOfLastElement);\n\n        return moveElementToPositionInHeap(modifiedHeap[indexOfLastElement], modifiedHeap);\n    };\n    const removeAndReturnTopElement = (): HeapElement => sortHeap(heap, 1).pop();\n    const toSortedArray = (currentHeap: HeapElement[]): HeapElement[] => {\n\n        return currentHeap.slice()\n            .map(() => removeAndReturnTopElement());\n    };\n    const size = (): number => heap.length;\n    const top = (): HeapElement => heap[0];\n    const pop = (): HeapElement => removeAndReturnTopElement();\n    const map = (callback: (element: HeapElement) => HeapElement): BinaryHeap<HeapElement> => {\n\n        const newHeap: BinaryHeap<HeapElement> = binaryHeap<HeapElement>(getValue);\n\n        heap.forEach((element) => newHeap.push(callback(element)));\n\n        return newHeap;\n    };\n    const forEach = (callback: (element: HeapElement) => any): void => toSortedArray(heap)\n        .forEach((element) => callback(element));\n\n    return {\n        forEach,\n        map,\n        pop,\n        size,\n        top,\n        push(value: HeapElement): BinaryHeap<HeapElement> {\n\n            heap = moveElementToPositionInHeap(value, heap);\n\n            return this;\n        },\n        setToMax(): BinaryHeap<HeapElement> {\n\n            isMaxHeap = true;\n\n            return this;\n        },\n        setToMin(): BinaryHeap<HeapElement> {\n\n            isMaxHeap = false;\n\n            return this;\n        },\n    };\n}\n"]}