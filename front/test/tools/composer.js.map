{"version":3,"file":"composer.js","sourceRoot":"","sources":["composer.ts"],"names":[],"mappings":";;AAaA;IAEI,MAAM,sBAAsB,GAAG,CAAC,SAAc,KAAc,SAAS,KAAK,SAAS,CAAC;IACpF,MAAM,4BAA4B,GAAG,CAAC,SAAc,KAAc,CAAC,SAAS,CAAC;IAC7E,MAAM,sBAAsB,GAAG,CAE3B,UAAe,EACf,mBAAwB,EACxB,UAAsB,EACtB,SAAsC;QAItC,MAAM,kBAAkB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QACzD,MAAM,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;QAE7D,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,eAAe;YAExD,MAAM,SAAS,GAAG,UAAU,CAAC,eAAe,CAAC,CAAC;YAC9C,MAAM,mBAAmB,GAAG,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;YAEvD,EAAE,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,mBAAmB,CAAC,CAAC,CAAC;gBAE9C,QAAQ,CAAC,eAAe,CAAC,GAAG,mBAAmB,CAAC,eAAe,CAAC,CAAC;YACrE,CAAC;YAED,MAAM,CAAC,QAAQ,CAAC;QAEpB,CAAC,EAAE,kBAAkB,CAAC,CAAC;IAC3B,CAAC,CAAC;IACF,MAAM,oBAAoB,GAAG,CAEzB,kBAA8B,EAC9B,UAAkB,EAClB,mBAA2B;QAI3B,MAAM,CAAC,sBAAsB,CACzB,UAAU,EACV,mBAAmB,EACnB,kBAAkB,EAClB,4BAA4B,CAC/B,CAAC;IACN,CAAC,CAAC;IACF,MAAM,oBAAoB,GAAG,CAEzB,iBAA6B,EAC7B,UAAkB,EAClB,mBAA2B;QAI3B,MAAM,CAAC,sBAAsB,CACzB,UAAU,EACV,mBAAmB,EACnB,iBAAiB,EACjB,sBAAsB,CACzB,CAAC;IACN,CAAC,CAAC;IACF,MAAM,0BAA0B,GAAG,CAAC,UAAoB;QAEpD,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,eAA2B,EAAE,SAAiB;YAEpE,eAAe,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC;YAElC,MAAM,CAAC,eAAe,CAAC;QAE3B,CAAC,EAAE,EAAE,CAAe,CAAC;IACzB,CAAC,CAAC;IACF,MAAM,SAAS,GAAG,CAAC,gBAA8C;QAE7D,MAAM,CAAC,CAAC,KAAU,KAAiB,gBAAgB;aAC9C,KAAK,EAAE;aACP,OAAO,EAAE;aACT,MAAM,CAAC,CAAC,KAAK,EAAE,eAAe,KAAK,eAAe,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;IAC3E,CAAC,CAAC;IACF,MAAM,UAAU,GAAG,CAEf,mBAA+B,EAC/B,mBAA+B,EAC/B,OAAc;QAId,MAAM,KAAK,GAAG,CAAC,CAAC;QAChB,MAAM,UAAU,GAAW,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QACzD,MAAM,WAAW,GAAY,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC;QAC7E,MAAM,oBAAoB,GAAW,OAAO;aACvC,KAAK,CAAC,CAAC,CAAC;aACR,MAAM,CAAC,CAAC,QAAQ,EAAE,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;QAEvE,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YAEd,MAAM,CAAC,oBAAoB,CAAC,mBAAmB,EAAE,UAAU,EAAE,oBAAoB,CAAC,CAAC;QACvF,CAAC;QAED,MAAM,CAAC,oBAAoB,CAAC,mBAAmB,EAAE,UAAU,EAAE,oBAAoB,CAAC,CAAC;IACvF,CAAC,CAAC;IACF,MAAM,SAAS,GAAG,CAAC,UAAoB,EAAE,GAAG,OAAc;QAEtD,MAAM,kBAAkB,GAAG,0BAA0B,CAAC,UAAU,CAAC,CAAC;QAElE,MAAM,CAAC,UAAU,CAAC,kBAAkB,EAAE,EAAE,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC,CAAC;IACF,MAAM,SAAS,GAAG,CAAC,UAAoB,EAAE,GAAG,OAAc;QAEtD,MAAM,kBAAkB,GAAG,0BAA0B,CAAC,UAAU,CAAC,CAAC;QAElE,MAAM,CAAC,UAAU,CAAC,EAAE,EAAE,kBAAkB,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC,CAAC;IACF,MAAM,OAAO,GAAG,CAAC,GAAG,OAAc,KAAiB,UAAU,CAAC,EAAE,EAAE,EAAE,EAAE,OAAO,CAAC,CAAC;IAE/E,MAAM,CAAC;QAEH,OAAO;QACP,SAAS;QACT,SAAS;QACT,SAAS;KACZ,CAAC;AACN,CAAC;AAxHD,4BAwHC","sourcesContent":["interface TruthTable {\n\n    [index: string]: boolean;\n}\n\nexport interface Composer<OutputType> {\n\n    functions(arrayOfFunctions: Array<((input: any) => any)>): (input: any) => any;\n    including(parameters: string[], ...objects: any[]): OutputType;\n    excluding(elements: string[], ...objects: any[]): OutputType;\n    combine(...objects: any[]): OutputType;\n}\n\nexport default function<OutputType>(): Composer<OutputType> {\n\n    const checkIfParameterExists = (parameter: any): boolean => parameter !== undefined;\n    const checkIfParameterDoesNotExist = (parameter: any): boolean => !parameter;\n    const conditionalCombination = (\n\n        baseObject: any,\n        objectToCombineWith: any,\n        conditions: TruthTable,\n        isAllowed: (parameter: any) => boolean,\n\n    ): OutputType => {\n\n        const modifiedBaseObject = Object.assign({}, baseObject);\n        const parametersToCombine = Object.keys(objectToCombineWith);\n\n        return parametersToCombine.reduce((composed, nameOfParameter) => {\n\n            const parameter = conditions[nameOfParameter];\n            const doesNotAlreadyExist = !composed[nameOfParameter];\n\n            if (isAllowed(parameter) && doesNotAlreadyExist) {\n\n                composed[nameOfParameter] = objectToCombineWith[nameOfParameter];\n            }\n\n            return composed;\n\n        }, modifiedBaseObject);\n    };\n    const exclusiveCombination = (\n\n        unwantedParameters: TruthTable,\n        baseObject: object,\n        objectToCombineWith: object,\n\n    ): OutputType => {\n\n        return conditionalCombination(\n            baseObject,\n            objectToCombineWith,\n            unwantedParameters,\n            checkIfParameterDoesNotExist,\n        );\n    };\n    const inclusiveCombination = (\n\n        desiredParameters: TruthTable,\n        baseObject: object,\n        objectToCombineWith: object,\n\n    ): OutputType => {\n\n        return conditionalCombination(\n            baseObject,\n            objectToCombineWith,\n            desiredParameters,\n            checkIfParameterExists,\n        );\n    };\n    const createTruthTableFromObject = (parameters: string[]): TruthTable => {\n\n        return parameters.reduce((parameterHolder: TruthTable, parameter: string): TruthTable => {\n\n            parameterHolder[parameter] = true;\n\n            return parameterHolder;\n\n        }, {}) as TruthTable;\n    };\n    const functions = (arrayOfFunctions: Array<((input: any) => any)>): (input: any) => any => {\n\n        return (input: any): OutputType => arrayOfFunctions\n            .slice()\n            .reverse()\n            .reduce((value, currentFunction) => currentFunction(value), input);\n    };\n    const combineAll = (\n\n        parametersToInclude: TruthTable,\n        parametersToExclude: TruthTable,\n        objects: any[],\n\n    ): OutputType => {\n\n        const empty = 0;\n        const baseObject: object = Object.assign({}, objects[0]);\n        const isInclusive: boolean = Object.keys(parametersToInclude).length > empty;\n        const objectsToCombineWith: object = objects\n            .slice(1)\n            .reduce((combined, object) => Object.assign(combined, object), {});\n\n        if (isInclusive) {\n\n            return inclusiveCombination(parametersToInclude, baseObject, objectsToCombineWith);\n        }\n\n        return exclusiveCombination(parametersToExclude, baseObject, objectsToCombineWith);\n    };\n    const including = (parameters: string[], ...objects: any[]): OutputType => {\n\n        const includedParameters = createTruthTableFromObject(parameters);\n\n        return combineAll(includedParameters, {}, objects);\n    };\n    const excluding = (parameters: string[], ...objects: any[]): OutputType => {\n\n        const excludedParameters = createTruthTableFromObject(parameters);\n\n        return combineAll({}, excludedParameters, objects);\n    };\n    const combine = (...objects: any[]): OutputType => combineAll({}, {}, objects);\n\n    return {\n\n        combine,\n        excluding,\n        functions,\n        including,\n    };\n}\n"]}