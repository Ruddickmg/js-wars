{"version":3,"file":"list.js","sourceRoot":"","sources":["list.ts"],"names":[],"mappings":"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","sourcesContent":["export interface List {\n\n    isEmpty(): boolean;\n    getCurrentIndex(): number;\n    getCurrentElement(): any;\n    moveToFirstElement(): any;\n    next(): any;\n    previous(): any;\n    moveToLastElement(): any;\n    addElement(element: any): List;\n    addElements(elementsToBeAdded: any[]): List;\n    moveToElement(property: any): List;\n    filter(callback: (value: any, index: number, array: any[]) => any[]): List;\n    map(callback: (value: any, index: number, array: any[]) => any[]): List;\n    sort(callback: (a: any, b: any) => number): List;\n    reduce(callback: (accumulator: any, value: any, index: number, array: any[]) => any): any;\n    forEach(callback: (value: any, index: number, array: any[]) => void): void;\n    find(callback: (value: any, index: number, array: any[]) => any): any;\n    getNeighboringElements(numberOfNeighboringElements: number): any[];\n}\n\nexport default function createList(initialElements: any[]= []): List {\n\n    let elements: any[] = initialElements;\n    let index: number = 0;\n    const minimumIndex: number = 0;\n\n    // consider option to toggle wrap around behavior\n    const previous = (): any => getElementAtIndex(moveToIndex(wrapIndexAroundLength(index - 1)));\n\n    const next = (): any => getElementAtIndex(moveToIndex(wrapIndexAroundLength(index + 1)));\n\n    const isEmpty = (): boolean => !elements.length;\n\n    const setIndex = (desiredIndex: number): number => {\n\n        index = desiredIndex;\n\n        return index;\n    };\n\n    const wrapIndexAroundLength = (unwrappedIndex: number): number => {\n\n        const length = elements.length;\n\n        if (unwrappedIndex >= length) {\n\n            return unwrappedIndex - length;\n        }\n        return unwrappedIndex < minimumIndex ? length + unwrappedIndex : unwrappedIndex;\n    };\n\n    const getCurrentIndex = (): number => index;\n\n    const getCurrentElement = (): any => getElementAtIndex(index);\n\n    const getElementAtIndex = (desiredIndex: number): any => {\n\n        return elements[desiredIndex];\n    };\n\n    const moveToIndex = (desiredIndex: number): number => {\n\n        return setIndex(wrapIndexAroundLength(desiredIndex));\n    };\n\n    const moveToFirstElement = (): any => getElementAtIndex(setIndex(minimumIndex));\n\n    const moveToLastElement = (): any => {\n\n        const end: number = elements.length - 1;\n        const indexOfLastElement: number = end > minimumIndex ? end : minimumIndex;\n\n        return getElementAtIndex(moveToIndex(indexOfLastElement));\n    };\n\n    const copyCurrentList = (desiredElements: any[]): List => {\n\n        const current = getElementAtIndex(index);\n\n        return createList(desiredElements).moveToElement(current);\n    };\n\n    const filter = (callback: (value: any, index: number, array: any[]) => any[]): List => {\n\n        return copyCurrentList(elements.filter(callback));\n    };\n\n    const find = (callback: (value: any, index: number, array: any[]) => any): any => {\n\n        return elements.find(callback);\n    };\n\n    const map = (callback: (value: any, index: number, array: any[]) => any[]): List => {\n\n        return copyCurrentList(elements.map(callback));\n    };\n\n    const reduce = (callback: (accumulator: any, value: any, index: number, array: any[]) => any): any => {\n\n        return elements.reduce(callback);\n    };\n\n    const forEach = (callback: (value: any, index: number, array: any[]) => void): void => {\n\n        elements.forEach(callback);\n    };\n\n    const sort = (callback: (a: any, b: any) => number): List => {\n\n        const copyOfElements = elements.slice();\n\n        return copyCurrentList(copyOfElements.sort(callback));\n    };\n\n    const getNeighboringElements = (numberOfNeighboringElements: number = 1): any[] => {\n\n        const amountOfElements = elements.length;\n        const amountOfCurrentElements = 1;\n        const amountOfNeighboringElements = numberOfNeighboringElements * 2;\n        const notEnoughElementsInList = amountOfElements < amountOfNeighboringElements + amountOfCurrentElements;\n        const length = index + numberOfNeighboringElements;\n        const currentAndNeighboringElements = [];\n\n        let indexOfNeighbor = index - numberOfNeighboringElements;\n        let wrappedIndex;\n        let neighbor;\n\n        if (notEnoughElementsInList) {\n\n            throw new Error(`Not enough elements in list to accommodate ${numberOfNeighboringElements} neighbors`);\n        }\n\n        for (indexOfNeighbor; indexOfNeighbor <= length; indexOfNeighbor += 1) {\n\n            wrappedIndex = wrapIndexAroundLength(indexOfNeighbor);\n            neighbor = elements[wrappedIndex];\n\n            currentAndNeighboringElements.push(neighbor);\n        }\n\n        return currentAndNeighboringElements;\n    };\n\n    const addElement = function(element: any): List {\n\n        elements.push(element);\n\n        return this;\n    };\n\n    const addElements = function(elementsToBeAdded: any[]): List {\n\n        elements = elements.concat(elementsToBeAdded);\n\n        return this;\n    };\n\n    const moveToElement = function(element: any): List {\n\n        const indexOfDesiredElement: number = elements.indexOf(element);\n\n        if (!isNaN(indexOfDesiredElement)) {\n\n            setIndex(indexOfDesiredElement);\n        }\n\n        return this;\n    };\n\n    return {\n\n        addElement,\n        addElements,\n        getCurrentElement,\n        getCurrentIndex,\n        filter,\n        find,\n        forEach,\n        isEmpty,\n        map,\n        moveToElement,\n        moveToFirstElement,\n        moveToLastElement,\n        getNeighboringElements,\n        next,\n        previous,\n        reduce,\n        sort,\n    };\n}\n"]}